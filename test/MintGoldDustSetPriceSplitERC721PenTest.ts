require("dotenv").config();
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { expect, use } from "chai";
import { Contract, ContractFactory } from "ethers";
import { ethers } from "hardhat";
import chai from "chai";
import chaiAsPromised from "chai-as-promised";

chai.use(chaiAsPromised);

const toWei = (num: any) => ethers.utils.parseEther(num.toString());
const fromWei = (num: any) => ethers.utils.formatEther(num);

describe("\nMGDSetPrice.sol Smart Contract \n___________________________________________________\n \nThis smart contract is responsible by all functionalities related with the fixed price market. \n Here goes the tests related with the MintGoldDustSetPrice market and the MintGoldDustERC1155 tokens. \n\n", function () {
  let MintGoldDustERC721: ContractFactory;
  let mintGoldDustERC721: Contract;

  let MintGoldDustERC1155: ContractFactory;
  let mintGoldDustERC1155: Contract;

  let MintGoldDustCompany: ContractFactory;
  let mgdCompany: Contract;

  let MintGoldDustSetPrice: ContractFactory;
  let mintGoldDustSetPrice: Contract;

  let MintGoldDustMemoir: ContractFactory;
  let mintGoldDustMemoir: Contract;

  let MintGoldDustMarketplaceAuction: ContractFactory;
  let mintGoldDustMarketplaceAuction: Contract;

  let deployer: SignerWithAddress;
  let addr1: SignerWithAddress;
  let addr2: SignerWithAddress;
  let addr3: SignerWithAddress;
  let addr4: SignerWithAddress;
  let addr5: SignerWithAddress;
  let addr6: SignerWithAddress;
  let addr7: SignerWithAddress;
  let addr8: SignerWithAddress;
  let addr9: SignerWithAddress;
  let addrs: SignerWithAddress[];

  let URI = "sample URI";
  let baseURI = "https://example.com/{id}.json";

  const MEMOIR = "This is a great moment of my life!";

  //const REAL_OWNER = "0x46ab5D1518688f66286aF7c6C9f5552edd050d15";
  const TEST_OWNER = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266";
  const primary_sale_fee_percent_initial = 15000000000000000000n;
  const secondary_sale_fee_percent_initial = 5000000000000000000n;
  const collector_fee_initial = 3000000000000000000n;
  const max_royalty_initial = 20000000000000000000n;
  const auction_duration = 5;
  const auction_extension_duration = 1;

  let primary_sale_fee_percent = 15;
  let secondary_sale_fee_percent = 5;
  let collector_fee = 3;
  let max_royalty = 20;
  let royalty = 5;

  beforeEach(async function () {
    MintGoldDustCompany = await ethers.getContractFactory(
      "MintGoldDustCompany"
    );

    MintGoldDustMarketplaceAuction = await ethers.getContractFactory(
      "MintGoldDustMarketplaceAuction"
    );

    MintGoldDustERC721 = await ethers.getContractFactory("MintGoldDustERC721");
    MintGoldDustSetPrice = await ethers.getContractFactory(
      "MintGoldDustSetPrice"
    );
    MintGoldDustERC1155 = await ethers.getContractFactory(
      "MintGoldDustERC1155"
    );
    MintGoldDustMemoir = await ethers.getContractFactory("MintGoldDustMemoir");

    mintGoldDustMemoir = await MintGoldDustMemoir.deploy();
    await mintGoldDustMemoir.deployed();

    [
      deployer,
      addr1,
      addr2,
      addr3,
      addr4,
      addr5,
      addr6,
      addr7,
      addr8,
      addr9,
      ...addrs
    ] = await ethers.getSigners();

    mgdCompany = await upgrades.deployProxy(
      MintGoldDustCompany,
      [
        TEST_OWNER,
      ],
      { initializer: "initialize" }
    );
    await mgdCompany.deployed();

    mintGoldDustERC721 = await upgrades.deployProxy(
      MintGoldDustERC721,
      [mgdCompany.address],
      {
        initializer: "initializeChild",
      }
    );

    mintGoldDustERC1155 = await upgrades.deployProxy(
      MintGoldDustERC1155,
      [mgdCompany.address, baseURI],
      {
        initializer: "initializeChild",
      }
    );
    await mintGoldDustERC1155.deployed();

    mintGoldDustSetPrice = await upgrades.deployProxy(
      MintGoldDustSetPrice,
      [
        mgdCompany.address,
        mintGoldDustERC721.address,
        mintGoldDustERC1155.address,
      ],
      { initializer: "initializeChild" }
    );
    await mintGoldDustSetPrice.deployed();

    mintGoldDustMarketplaceAuction = await upgrades.deployProxy(
      MintGoldDustMarketplaceAuction,
      [
        mgdCompany.address,
        mintGoldDustERC721.address,
        mintGoldDustERC1155.address,
      ],
      { initializer: "initializeChild" }
    );
    await mintGoldDustMarketplaceAuction.deployed();

    await mgdCompany.connect(deployer).setValidator(deployer.address, true);

    await mintGoldDustERC1155
      .connect(deployer)
      .setMintGoldDustSetPriceAddress(mintGoldDustSetPrice.address);

    await mintGoldDustERC721
      .connect(deployer)
      .setMintGoldDustSetPriceAddress(mintGoldDustSetPrice.address);

    await mintGoldDustERC1155
      .connect(deployer)
      .setMintGoldDustMarketplaceAuctionAddress(
        mintGoldDustMarketplaceAuction.address
      );

    await mintGoldDustERC721
      .connect(deployer)
      .setMintGoldDustMarketplaceAuctionAddress(
        mintGoldDustMarketplaceAuction.address
      );

    await mintGoldDustMarketplaceAuction
      .connect(deployer)
      .setMintGoldDustMarketplace(mintGoldDustSetPrice.address);

    await mintGoldDustSetPrice
      .connect(deployer)
      .setMintGoldDustMarketplace(mintGoldDustMarketplaceAuction.address);
  });

  describe("\n--------------- Tests related witn the list NFT functionality ---------------\n", function () {
    let price = 1;
    let quantityToMint = 1;
    let quantityToList = 1;

    // Create an instance of the ListDTO struct

    beforeEach(async () => {
      // MGD owner whitelist the artist
      await mgdCompany.connect(deployer).whitelist(addr1.address, true);
    });

    it("Should revert with a TheTotalPercentageCantBeGreaterOrLessThan100 error if the owners percentage are less than 100%. I.e first 99% and the last one 0.9999999999999 %", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address],
            [toWei(99), toWei(0.9999999999999)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.revertedWithCustomError(
        mintGoldDustERC721,
        "TheTotalPercentageCantBeGreaterOrLessThan100"
      );
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if the collaborators percentage are less than 0%. I.e first 0% and the last one 99%", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address],
            [toWei(0), toWei(100)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.revertedWith("Owner percentage must be greater than zero!");
    });

    it("Should revert with a 'TheTotalPercentageCantBeGreaterOrLessThan100' error if the collaborators percentage are less than 0%. I.e first 0% and the last one 99%", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address],
            [toWei(100), toWei(100)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.revertedWithCustomError(
        mintGoldDustERC721,
        "TheTotalPercentageCantBeGreaterOrLessThan100"
      );
    });

    it("Should revert with a 'NumberOfCollaboratorsAndPercentagesNotMatch' error if the collaborators percentage are less than 0%. I.e first 0% and the last one 99%", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address],
            [toWei(100), toWei(100)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.revertedWithCustomError(
        mintGoldDustERC721,
        "NumberOfCollaboratorsAndPercentagesNotMatch"
      );
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if some of the collaborators percentage are  0%.", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address, addr2.address, addr3.address],
            [toWei(20), toWei(0), toWei(20), toWei(20), toWei(20)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.rejectedWith("Owner percentage must be greater than zero!");
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if some of the collaborators percentage are  0%.", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address, addr2.address, addr3.address],
            [toWei(20), toWei(0), toWei(20), toWei(20), toWei(20)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.rejectedWith("Owner percentage must be greater than zero!");
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if some of the collaborators percentage are  0%.", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address, addr2.address, addr3.address],
            [toWei(20), toWei(20), toWei(0), toWei(20), toWei(20)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.rejectedWith("Owner percentage must be greater than zero!");
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if some of the collaborators percentage are  0%.", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address, addr2.address, addr3.address],
            [toWei(20), toWei(20), toWei(20), toWei(0), toWei(20)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.rejectedWith("Owner percentage must be greater than zero!");
    });

    it("Should revert with a 'Owner percentage must be greater than zero!' error if some of the last collaborator percentage is 0%.", async function () {
      const encode = new TextEncoder();
      const bytesMemoir = encode.encode(MEMOIR);

      // addr1 mints a nft
      await expect(
        mintGoldDustERC721
          .connect(addr1)
          .splitMint(
            URI,
            toWei(5),
            [addr5.address, addr1.address, addr2.address, addr3.address],
            [toWei(20), toWei(20), toWei(20), toWei(40), toWei(0)],
            quantityToMint,
            bytesMemoir
          )
      ).to.be.revertedWith("Owner percentage must be greater than zero!");
    });
  });
});
